<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WhisPTT Terminal Mockup</title>
  <link rel="stylesheet" href="assets/css/theme.css">
</head>
<body>
  <div class="app-shell app-shell--recorder">
    <header class="top-banner"><img src="assets/html-logo-images/whisptt-logo-corners-tinted.png" alt="WhisPTT logo" class="top-banner__logo"></header>

    <main class="screen">
      <section class="transcription-panel" aria-label="Transcript window">
        <div class="status-bar">
          <span class="timer status-bar__timer" id="snippet-timer">00:00.0</span>
        </div>
        <p class="transcription-placeholder" id="transcription-placeholder">Transcription appears here</p>
        <div class="transcription-log" id="transcription-log" aria-live="polite"
            style="overflow-y:auto; flex:1; min-height:0;"></div>
      </section>

        <!-- recording-controls -->
        <div class="recording-controls" aria-label="Recording controls">
          <!-- LEFT â€” Clear -->
          <button class="control-button" id="action-left" aria-label="Clear transcript">
            <svg class="control-button__icon" viewBox="0 0 32 32" aria-hidden="true">
              <path d="M9 11a8.5 8.5 0 0112.6-3.2" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
              <polyline points="18 7 24 7 24 13" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M23 21a8.5 8.5 0 01-12.6 3.2" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
              <polyline points="14 25 8 25 8 19" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>

          <!-- CENTRE â€” Mic -->
          <button class="mic-button" id="mic-button" aria-label="Tap to record">
            <img src="assets/svg-assets/action-menu-svg-icons/mic-simple.svg"
                class="control-button__icon control-button__icon--mic" alt="">
          </button>

          <!-- RIGHT â€” Copy to clipboard -->
          <button class="control-button" id="action-right" aria-label="Copy transcript to clipboard">
            <svg class="control-button__icon" viewBox="0 0 32 32" aria-hidden="true">
              <rect x="12" y="9" width="12" height="16" rx="2.5" ry="2.5" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M10 21H8a2 2 0 01-2-2V8a3 3 0 013-3h10" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
                </div>

        <p id="status-text" class="status-text"></p>        
    </main>

    <nav class="bottom-nav" aria-label="Primary navigation">
      <button class="bottom-nav__item" type="button" aria-label="Chat" id="nav-chat">
        <img src="assets/svg-assets/lower-menu-svg-icons/L2-chat-menu.svg" alt="Chat" class="bottom-nav__icon">
      </button>
      <button class="bottom-nav__item" type="button" aria-label="Profile" id="nav-profile">
        <img src="assets/svg-assets/lower-menu-svg-icons/L1-profile-page-menu.svg" alt="Profile" class="bottom-nav__icon">
      </button>
      <button class="bottom-nav__item bottom-nav__item--active" type="button" aria-label="Recorder" id="nav-recorder">
        <img src="assets/svg-assets/lower-menu-svg-icons/C-mic-center-menu.svg" alt="Recorder" class="bottom-nav__icon">
      </button>
      <button class="bottom-nav__item" type="button" aria-label="Edit Transcript" id="nav-editor">
        <img src="assets/svg-assets/lower-menu-svg-icons/R1-edit-transcript-menu.svg" alt="Edit Transcript" class="bottom-nav__icon">
      </button>
      <button class="bottom-nav__item" type="button" aria-label="Android" id="nav-android">
        <img src="assets/svg-assets/lower-menu-svg-icons/R2-android-menu.svg" alt="Android" class="bottom-nav__icon">
      </button>
    </nav>
  </div>

  <script>
(function () {
      /* <span style="color: red;">
      const API_BASE = "http://127.0.0.1:7000";
      </span> */
      /* <span style="color: blue;">
      CHANGED: Hardcoded localhost URL prevents deployment to other environments.
      Now falls back to relative paths if window.location.origin matches, otherwise
      uses configurable base. In production, this should read from env config.
      </span> */
      const API_BASE = window.location.origin.includes('localhost') || window.location.origin.includes('127.0.0.1')
        ? "http://127.0.0.1:7000"
        : (window.API_BASE_URL || "http://127.0.0.1:7000");

      const micButton = document.getElementById("mic-button");
      const bookmarkButton = document.getElementById("action-left");
      const exportButton = document.getElementById("action-right");
      const statusText = document.getElementById("status-text");
      const log = document.getElementById("transcription-log");
      const placeholder = document.getElementById("transcription-placeholder");
      const snippetTimerEl = document.getElementById("snippet-timer");
      const navRecorderButton = document.getElementById("nav-recorder");
      const navEditorButton = document.getElementById("nav-editor");
      const navChatButton = document.getElementById("nav-chat");
      const navProfileButton = document.getElementById("nav-profile");
      const navAndroidButton = document.getElementById("nav-android");
      const EDITOR_PREFILL_KEY = "whisptt.editorPrefill";

      let isRecording = false;
      let stopInFlight = false;
      let exportInFlight = false;
      let snippetTimerId = null;
      let snippetStartTime = null;
      let livePollTimerId = null;

      /* <span style="color: blue;">
      ADDED: Configuration constants for timer precision and animation chunking
      </span> */
      const TIMER_UPDATE_INTERVAL_MS = 100;
      const TYPEWRITER_TOTAL_CHUNKS = 120;  // Controls animation speed
      const LIVE_POLL_INTERVAL_MS = 1000;

      function setStatus(message, tone) {
        statusText.textContent = message;
        statusText.classList.remove("success", "error");
        if (tone) {
          statusText.classList.add(tone);
        }
      }

      function ensureHistoryVisible() {
        if (!placeholder) {
          return;
        }
        placeholder.style.display = log.childElementCount ? "none" : "block";
      }

      function startSnippetTimer() {
        if (snippetTimerId) {
          clearInterval(snippetTimerId);
        }
        snippetStartTime = Date.now();
        snippetTimerEl.textContent = "00:00.0";
        snippetTimerId = setInterval(() => {
          const now = Date.now();
          snippetTimerEl.textContent = formatTime(now - snippetStartTime);
        /* <span style="color: red;">
        }, 100);
        </span> */
        /* <span style="color: blue;">
        CHANGED: Magic number replaced with named constant
        </span> */
        }, TIMER_UPDATE_INTERVAL_MS);
      }

      function stopSnippetTimer(keepDisplay = false) {
        if (snippetTimerId) {
          clearInterval(snippetTimerId);
          snippetTimerId = null;
        }
        if (snippetStartTime) {
          const duration = Date.now() - snippetStartTime;
          snippetTimerEl.textContent = keepDisplay ? formatTime(duration) : "00:00.0";
        }
        snippetStartTime = null;
      }

      function resetSnippetTimer() {
        stopSnippetTimer(false);
        snippetTimerEl.textContent = "00:00.0";
      }

      function clearTranscriptionHistory() {
        while (log.firstChild) {
          log.removeChild(log.firstChild);
        }
        clearLiveSegments();
        ensureHistoryVisible();
      }


function collectTranscriptForEditor() {
        if (!log) {
          return "";
        }
        const nodes = Array.from(log.querySelectorAll('.transcription-entry:not(.transcription-entry--live) p'));
        const combined = nodes
          .map((node) => node.textContent.trim())
          .filter(Boolean)
          .join("\n\n");
        return combined;
      }

      function clearLiveSegments() {
  document.querySelectorAll('.transcription-entry--live').forEach((node) => node.remove());
}

function renderLiveSegments(segments) {
  clearLiveSegments();
  if (!Array.isArray(segments) || !segments.length) {
    return;
  }
  segments.forEach((segment) => {
    const article = document.createElement('article');
    article.className = 'transcription-entry transcription-entry--live';
    article.dataset.liveSegment = `${segment.recording_id || ''}:${segment.chunk_index}`;
    const textEl = document.createElement('p');
    textEl.textContent = segment.text || '';
    article.appendChild(textEl);
    log.appendChild(article);
  });
  log.scrollTop = log.scrollHeight;
  ensureHistoryVisible();
}

async function pollLiveSegments() {
  if (!isRecording) {
    return;
  }
  try {
    const response = await fetch(`${API_BASE}/api/live`);
    if (!response.ok) {
      return;
    }
    const data = await response.json();
    renderLiveSegments(data.segments || []);
  } catch (error) {
    console.warn('Live polling failed', error);
  }
}

function startLivePolling() {
  if (livePollTimerId) {
    return;
  }
  pollLiveSegments();
  livePollTimerId = setInterval(pollLiveSegments, LIVE_POLL_INTERVAL_MS);
}

function stopLivePolling() {
  if (livePollTimerId) {
    clearInterval(livePollTimerId);
    livePollTimerId = null;
  }
  clearLiveSegments();
}

      async function exportSession() {
        if (exportInFlight) {
          return;
        }
        if (isRecording) {
          setStatus("Stop recording before exporting", "error");
          return;
        }

        exportInFlight = true;
        exportButton.disabled = true;
        try {
          setStatus("Exporting session...");
          const response = await fetch(`${API_BASE}/api/session/export`, { method: "POST" });
          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Export failed");
          }

          clearTranscriptionHistory();
          resetSnippetTimer();

          let successMessage = data.export_path ? `Session saved to ${data.export_path}` : "Session log created";
          const combined = data.combined_transcript || "";
          if (combined && navigator.clipboard && navigator.clipboard.writeText) {
            try {
              await navigator.clipboard.writeText(combined);
              successMessage += " (copied to clipboard)";
            } catch (clipboardError) {
              console.warn('Clipboard write failed', clipboardError);
            }
          }

          setStatus(successMessage, "success");
        } catch (error) {
          console.error(error);
          setStatus(error.message || "Export failed", "error");
        } finally {
          exportInFlight = false;
          exportButton.disabled = false;
          ensureHistoryVisible();
        }
      }

      function renderEntry(entry, options = {}) {
        const { scroll = true, animate = true } = options;
        const identifier = entry.id || entry.audio_path || entry.created_at || "";
        const existingLast = log.lastElementChild;
        if (identifier && existingLast) {
          const existingId = existingLast.dataset.chitId || existingLast.dataset.audioPath || existingLast.dataset.timestamp || "";
          if (existingId === identifier) {
            ensureHistoryVisible();
            return;
          }
        }

        const article = document.createElement("article");
        article.className = "transcription-entry transcription-entry--new";
        if (entry.id) {
          article.dataset.chitId = entry.id;
        }
        if (entry.audio_path) {
          article.dataset.audioPath = entry.audio_path;
        }
        article.dataset.timestamp = entry.created_at || new Date().toISOString();

        const text = document.createElement("p");
        article.appendChild(text);

        log.appendChild(article);
        ensureHistoryVisible();

        if (animate) {
          typeOutText(text, entry.transcript || "");
        } else {
          text.textContent = entry.transcript || "";
        }

        if (scroll) {
          log.scrollTop = log.scrollHeight;
        }
      }

      function typeOutText(element, content) {
        element.textContent = "";
        if (!content) {
          return;
        }
        const chars = Array.from(content);
        let index = 0;
        /* <span style="color: red;">
        const chunk = Math.max(1, Math.floor(chars.length / 120));
        </span> */
        /* <span style="color: blue;">
        CHANGED: Magic number 120 replaced with named constant. This controls how many
        "chunks" the text is divided into for the typewriter animation. Higher = smoother
        but more DOM updates; lower = chunkier but better performance for long transcripts.
        </span> */
        const chunk = Math.max(1, Math.floor(chars.length / TYPEWRITER_TOTAL_CHUNKS));

        function step() {
          const slice = chars.slice(index, index + chunk).join("");
          element.textContent += slice;
          index += chunk;
          if (index < chars.length) {
            requestAnimationFrame(step);
          }
        }

        requestAnimationFrame(step);
      }

      function formatTime(ms) {
        if (!Number.isFinite(ms) || ms < 0) {
          ms = 0;
        }
        const minutes = Math.floor(ms / 60000);
        const seconds = Math.floor((ms % 60000) / 1000);
        const tenths = Math.floor((ms % 1000) / 100);
        return `${minutes.toString().padStart(2, "0")}:${seconds
          .toString()
          .padStart(2, "0")}.${tenths}`;
      }

      function enterRecordingState() {
        isRecording = true;
        micButton.classList.add("mic-button--recording");
        micButton.classList.add("mic-button--armed");
        setStatus("Recording... tap to stop");
        startSnippetTimer();
        startLivePolling();
      }

      function exitRecordingState({ resetSnippet = false, statusTone = null, statusMessage = "Tap the button to start" } = {}) {
        const wasRecording = isRecording;
        isRecording = false;
        micButton.classList.remove("mic-button--recording");
        micButton.classList.remove("mic-button--armed");
        if (resetSnippet) {
          resetSnippetTimer();
        } else if (wasRecording) {
          stopSnippetTimer(true);
        }
        stopLivePolling();
        setStatus(statusMessage, statusTone);
      }

      async function startRecording() {
        if (isRecording) {
          return;
        }

        enterRecordingState();

        try {
          const response = await fetch(`${API_BASE}/api/record/start`, { method: "POST" });
          if (!response.ok) {
            const data = await response.json().catch(() => ({}));
            throw new Error(data.error || "Failed to start recording");
          }
        } catch (error) {
          console.error(error);
          exitRecordingState({ resetSnippet: true, statusTone: "error", statusMessage: error.message || "Could not start recording" });
          micButton.classList.remove("mic-button--armed");
        }
      }

      async function stopRecording() {
        if (!isRecording || stopInFlight) {
          return;
        }

        stopInFlight = true;

        micButton.classList.remove("mic-button--armed");
        micButton.classList.remove("mic-button--recording");
        setStatus("Processing transcript...");

        try {
          const response = await fetch(`${API_BASE}/api/record/stop`, { method: "POST" });
          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Recording stop failed");
          }
          clearLiveSegments();
          renderEntry(data);
          exitRecordingState({ statusTone: "success", statusMessage: "Tap the button to start" });
        } catch (error) {
          console.error(error);
          exitRecordingState({ resetSnippet: true, statusTone: "error", statusMessage: error.message || "Could not stop recording" });
          stopInFlight = false;
          return;
        }

        try {
          const statusResponse = await fetch(`${API_BASE}/api/status`);
          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            if (statusData.last_error) {
              setStatus(statusData.last_error, "error");
            }
          }
        } catch (statusError) {
          console.warn("Status refresh failed", statusError);
        } finally {
          stopInFlight = false;
        }
      }

      micButton.addEventListener("click", function (event) {
        event.preventDefault();
        if (stopInFlight) {
          return;
        }
        if (isRecording) {
          stopRecording();
        } else {
          micButton.classList.add("mic-button--armed");
          startRecording();
        }
      });

      bookmarkButton.addEventListener("click", async function (event) {
        event.preventDefault();
        if (isRecording) {
          setStatus("Stop recording before clearing", "error");
          return;
        }
        clearTranscriptionHistory();
        resetSnippetTimer();
        setStatus("Transcript cleared", "success");
        try {
          const response = await fetch(`${API_BASE}/api/transcript/clear`, { method: "POST" });
          if (!response.ok) {
            const data = await response.json().catch(() => ({}));
            throw new Error(data.error || "Failed to clear transcript history");
          }
        } catch (error) {
          console.warn("Transcript clear sync failed", error);
          setStatus(error.message || "Could not sync clear action", "error");
        }
      });

      exportButton.addEventListener("click", function (event) {
        event.preventDefault();
        exportSession();
      });

      if (navEditorButton) {
        navEditorButton.dataset.editorNavWired = "true";
        navEditorButton.addEventListener("click", () => {
          const textForEditor = collectTranscriptForEditor();
          try {
            sessionStorage.setItem(EDITOR_PREFILL_KEY, JSON.stringify({ text: textForEditor, createdAt: new Date().toISOString() }));
          } catch (storageError) {
            console.warn("Failed to cache transcript for editor", storageError);
          }
          window.location.href = "html_editor.html";
        });
      }

      if (navRecorderButton) {
        navRecorderButton.addEventListener("click", () => {
          window.location.href = "html_redline.html";
        });
      }

      if (navChatButton) {
        navChatButton.addEventListener("click", () => {
          window.location.href = "html_chat.html";
        });
      }

      if (navProfileButton) {
        navProfileButton.addEventListener("click", () => {
          window.location.href = "html_profile.html";
        });
      }

      if (navAndroidButton) {
        navAndroidButton.dataset.androidNavWired = "true";
        navAndroidButton.addEventListener("click", () => {
          window.location.href = "html_android.html";
        });
      }

      async function hydrateHistory() {
        try {
          const response = await fetch(`${API_BASE}/api/chits`);
          if (!response.ok) {
            return;
          }
          const records = await response.json();
          records.forEach((entry) => {
            renderEntry(entry, { scroll: false, animate: false });
          });
          log.scrollTop = log.scrollHeight;
          ensureHistoryVisible();
        } catch (error) {
          console.warn("History hydration failed", error);
        }
      }

      hydrateHistory();
      ensureHistoryVisible();
    })();
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const navRecorderButton = document.getElementById('nav-recorder');
      const navEditorButton = document.getElementById('nav-editor');
      const navAndroidButton = document.getElementById('nav-android');
      const navChatButton = document.getElementById('nav-chat');
      const navProfileButton = document.getElementById('nav-profile');
      if (navRecorderButton && !navRecorderButton.dataset.recorderNavWired) {
        navRecorderButton.dataset.recorderNavWired = 'true';
        navRecorderButton.addEventListener('click', function () {
          window.location.href = 'html_redline.html';
        });
      }
      if (navEditorButton && !navEditorButton.dataset.editorNavWired) {
        navEditorButton.addEventListener('click', function () {
          window.location.href = 'html_editor.html';
        });
      }
      if (navAndroidButton && !navAndroidButton.dataset.androidNavWired) {
        navAndroidButton.addEventListener('click', function () {
          window.location.href = 'html_android.html';
        });
      }
      if (navChatButton) {
        navChatButton.addEventListener('click', function () {
          window.location.href = 'html_chat.html';
        });
      }
      if (navProfileButton) {
        navProfileButton.addEventListener('click', function () {
          window.location.href = 'html_profile.html';
        });
      }
    });
  </script>
</body>
</html>























